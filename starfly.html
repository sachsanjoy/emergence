<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Starfly – 3D Star Map</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { background: #000; overflow: hidden; font-family: sans-serif; }
    canvas { display: block; }

    /* HUD overlay */
    #hud {
      position: fixed;
      top: 12px;
      left: 12px;
      color: rgba(180,220,255,0.85);
      font-size: 13px;
      pointer-events: none;
      text-shadow: 0 0 6px #4af;
      line-height: 1.6;
    }

    /* Mobile virtual joystick */
    #joystick-zone {
      position: fixed;
      bottom: 24px;
      left: 24px;
      width: 120px;
      height: 120px;
      border-radius: 50%;
      background: rgba(100,180,255,0.12);
      border: 2px solid rgba(100,180,255,0.35);
      touch-action: none;
      display: none;          /* shown only on touch devices */
    }
    #joystick-knob {
      position: absolute;
      width: 44px;
      height: 44px;
      border-radius: 50%;
      background: rgba(100,180,255,0.55);
      top: 50%; left: 50%;
      transform: translate(-50%,-50%);
      pointer-events: none;
    }
  </style>
</head>
<body>

<div id="hud">
  <div>STARFLY</div>
  <div id="pos-hud">Position: 0, 0, 0</div>
  <div style="margin-top:6px;font-size:11px;color:rgba(140,200,255,0.6);">
    WASD – move &nbsp;|&nbsp; Space/Shift – up/down
  </div>
</div>

<div id="joystick-zone">
  <div id="joystick-knob"></div>
</div>

<!-- Three.js r158 via CDN -->
<script src="https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.min.js"></script>

<script>
'use strict';

/* ─── Scene ─────────────────────────────────────────── */
const scene    = new THREE.Scene();
scene.fog      = new THREE.FogExp2(0x000010, 0.0012);

/* ─── Camera ─────────────────────────────────────────── */
const camera = new THREE.PerspectiveCamera(70, innerWidth / innerHeight, 0.1, 2000);
camera.position.set(0, 6, 18);   // start slightly behind and above player

/* ─── Renderer ───────────────────────────────────────── */
const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
renderer.setSize(innerWidth, innerHeight);
document.body.appendChild(renderer.domElement);

/* ─── Resize handler ─────────────────────────────────── */
window.addEventListener('resize', () => {
  camera.aspect = innerWidth / innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
});

/* ─── Lighting ───────────────────────────────────────── */
scene.add(new THREE.AmbientLight(0x223355, 2.5));
const pointLight = new THREE.PointLight(0x88aaff, 3, 60);
scene.add(pointLight);   // will follow the player

/* ─── Background stars (particle field) ─────────────── */
(function buildStarField() {
  const COUNT   = 4000;
  const RANGE   = 800;
  const positions = new Float32Array(COUNT * 3);
  const colors    = new Float32Array(COUNT * 3);
  const sizes     = new Float32Array(COUNT);

  // Subtle palette: blue-white, yellow-white, faint red
  const palette = [
    new THREE.Color(0.9, 0.9, 1.0),
    new THREE.Color(1.0, 1.0, 0.85),
    new THREE.Color(0.8, 0.9, 1.0),
    new THREE.Color(1.0, 0.85, 0.7),
    new THREE.Color(0.7, 0.8, 1.0),
  ];

  for (let i = 0; i < COUNT; i++) {
    positions[i * 3]     = (Math.random() - 0.5) * RANGE;
    positions[i * 3 + 1] = (Math.random() - 0.5) * RANGE;
    positions[i * 3 + 2] = (Math.random() - 0.5) * RANGE;

    const c = palette[Math.floor(Math.random() * palette.length)];
    const brightness = 0.4 + Math.random() * 0.6;
    colors[i * 3]     = c.r * brightness;
    colors[i * 3 + 1] = c.g * brightness;
    colors[i * 3 + 2] = c.b * brightness;

    sizes[i] = 0.5 + Math.random() * 2.5;
  }

  const geo = new THREE.BufferGeometry();
  geo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
  geo.setAttribute('color',    new THREE.BufferAttribute(colors,    3));
  geo.setAttribute('size',     new THREE.BufferAttribute(sizes,     1));

  // Custom shader material for round, glowing points
  const mat = new THREE.ShaderMaterial({
    vertexColors: true,
    transparent: true,
    depthWrite: false,
    vertexShader: `
      attribute float size;
      varying vec3 vColor;
      void main() {
        vColor = color;
        vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
        gl_PointSize = size * (300.0 / -mvPosition.z);
        gl_Position  = projectionMatrix * mvPosition;
      }
    `,
    fragmentShader: `
      varying vec3 vColor;
      void main() {
        float d = length(gl_PointCoord - vec2(0.5));
        if (d > 0.5) discard;
        float alpha = 1.0 - smoothstep(0.2, 0.5, d);
        gl_FragColor = vec4(vColor, alpha);
      }
    `,
  });

  scene.add(new THREE.Points(geo, mat));
}());

/* ─── Bright foreground stars (glowing spheres) ─────── */
(function buildNearbyStars() {
  const NEAR_COUNT = 80;
  const RANGE      = 180;
  const geo  = new THREE.SphereGeometry(0.4, 8, 8);

  for (let i = 0; i < NEAR_COUNT; i++) {
    const brightness = 0.5 + Math.random() * 0.5;
    const hue = Math.random();
    const color = new THREE.Color().setHSL(hue, 0.7, 0.6 * brightness);
    const mat   = new THREE.MeshBasicMaterial({ color });
    const mesh  = new THREE.Mesh(geo, mat);
    mesh.position.set(
      (Math.random() - 0.5) * RANGE,
      (Math.random() - 0.5) * RANGE,
      (Math.random() - 0.5) * RANGE,
    );
    mesh.scale.setScalar(0.3 + Math.random() * 1.4);
    scene.add(mesh);
  }
}());

/* ─── Player star ────────────────────────────────────── */
const playerGeo = new THREE.SphereGeometry(1, 32, 32);
const playerMat = new THREE.MeshBasicMaterial({ color: 0x44aaff });
const player    = new THREE.Mesh(playerGeo, playerMat);
scene.add(player);

// Glow sprite around the player
const glowCanvas = (function makeGlowTexture() {
  const size = 128;
  const c    = document.createElement('canvas');
  c.width = c.height = size;
  const ctx  = c.getContext('2d');
  const grad = ctx.createRadialGradient(size/2, size/2, 0, size/2, size/2, size/2);
  grad.addColorStop(0,   'rgba(100,180,255,0.9)');
  grad.addColorStop(0.3, 'rgba(60,140,255,0.5)');
  grad.addColorStop(1,   'rgba(0,0,100,0)');
  ctx.fillStyle = grad;
  ctx.fillRect(0, 0, size, size);
  return new THREE.CanvasTexture(c);
}());

const glowMat    = new THREE.SpriteMaterial({ map: glowCanvas, transparent: true, depthWrite: false, blending: THREE.AdditiveBlending });
const glowSprite = new THREE.Sprite(glowMat);
glowSprite.scale.set(8, 8, 1);
player.add(glowSprite);

/* ─── Movement state ─────────────────────────────────── */
const keys = {};
window.addEventListener('keydown', e => { keys[e.code] = true; });
window.addEventListener('keyup',   e => { keys[e.code] = false; });

const SPEED       = 0.18;
const playerVel   = new THREE.Vector3();   // for smooth damping

/* Camera offset in local space: behind and above the player */
const CAM_OFFSET = new THREE.Vector3(0, 5, 14);

/* ─── Touch / virtual joystick ───────────────────────── */
const joystickZone = document.getElementById('joystick-zone');
const joystickKnob = document.getElementById('joystick-knob');
const joystick     = { active: false, id: null, base: new THREE.Vector2(), delta: new THREE.Vector2() };
const KNOB_RADIUS  = 38;   // px

function isTouchDevice() {
  return 'ontouchstart' in window || navigator.maxTouchPoints > 0;
}
if (isTouchDevice()) {
  joystickZone.style.display = 'block';
}

joystickZone.addEventListener('touchstart', e => {
  e.preventDefault();
  const touch = e.changedTouches[0];
  joystick.active = true;
  joystick.id     = touch.identifier;
  const rect      = joystickZone.getBoundingClientRect();
  joystick.base.set(rect.left + rect.width / 2, rect.top + rect.height / 2);
}, { passive: false });

window.addEventListener('touchmove', e => {
  if (!joystick.active) return;
  for (const touch of e.changedTouches) {
    if (touch.identifier !== joystick.id) continue;
    const dx = touch.clientX - joystick.base.x;
    const dy = touch.clientY - joystick.base.y;
    const dist = Math.sqrt(dx*dx + dy*dy);
    const clampedDist = Math.min(dist, KNOB_RADIUS);
    const angle = Math.atan2(dy, dx);
    joystick.delta.set(
      Math.cos(angle) * clampedDist / KNOB_RADIUS,
      Math.sin(angle) * clampedDist / KNOB_RADIUS,
    );
    joystickKnob.style.transform =
      `translate(calc(-50% + ${Math.cos(angle)*clampedDist}px), calc(-50% + ${Math.sin(angle)*clampedDist}px))`;
    break;
  }
}, { passive: true });

function resetJoystick() {
  joystick.active = false;
  joystick.delta.set(0, 0);
  joystickKnob.style.transform = 'translate(-50%, -50%)';
}
window.addEventListener('touchend',    e => { for (const t of e.changedTouches) if (t.identifier === joystick.id) resetJoystick(); }, { passive: true });
window.addEventListener('touchcancel', e => { for (const t of e.changedTouches) if (t.identifier === joystick.id) resetJoystick(); }, { passive: true });

/* ─── HUD refs ───────────────────────────────────────── */
const posHud = document.getElementById('pos-hud');
let   hudTimer = 0;

/* ─── Animation loop ─────────────────────────────────── */
const clock = new THREE.Clock();

function animate() {
  requestAnimationFrame(animate);

  const delta = clock.getDelta();

  /* --- Compute desired movement from keyboard --- */
  const move = new THREE.Vector3();

  if (keys['KeyW'] || keys['ArrowUp'])    move.z -= 1;
  if (keys['KeyS'] || keys['ArrowDown'])  move.z += 1;
  if (keys['KeyA'] || keys['ArrowLeft'])  move.x -= 1;
  if (keys['KeyD'] || keys['ArrowRight']) move.x += 1;
  if (keys['Space'])                      move.y += 1;
  if (keys['ShiftLeft'] || keys['ShiftRight']) move.y -= 1;

  /* --- Add joystick input --- */
  if (joystick.active) {
    move.x += joystick.delta.x;
    move.z += joystick.delta.y;
  }

  /* --- Normalize diagonal movement --- */
  if (move.lengthSq() > 0) move.normalize();

  /* --- Apply camera-relative direction (yaw only) --- */
  const yaw = Math.atan2(
    camera.position.x - player.position.x,
    camera.position.z - player.position.z,
  );
  move.applyAxisAngle(new THREE.Vector3(0, 1, 0), yaw);

  /* --- Smooth velocity damping --- */
  playerVel.lerp(move.multiplyScalar(SPEED), 0.18);
  player.position.add(playerVel);

  /* --- Rotate player mesh to face direction of travel --- */
  if (playerVel.lengthSq() > 0.00001) {
    const target = player.position.clone().add(playerVel);
    player.lookAt(target);
  }

  /* --- Camera follows player smoothly --- */
  const desiredCamPos = player.position.clone().add(CAM_OFFSET);
  camera.position.lerp(desiredCamPos, 0.08);
  camera.lookAt(player.position);

  /* --- Point light tracks player --- */
  pointLight.position.copy(player.position);

  /* --- Pulse glow --- */
  const pulse = 1 + 0.25 * Math.sin(clock.getElapsedTime() * 3);
  glowSprite.scale.set(8 * pulse, 8 * pulse, 1);

  /* --- HUD update (every ~0.1 s to avoid layout thrash) --- */
  hudTimer += delta;
  if (hudTimer > 0.1) {
    hudTimer = 0;
    const p = player.position;
    posHud.textContent = `Position: ${p.x.toFixed(1)}, ${p.y.toFixed(1)}, ${p.z.toFixed(1)}`;
  }

  renderer.render(scene, camera);
}

animate();
</script>
</body>
</html>