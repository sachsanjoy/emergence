<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>Starfly 3D – Dual Stick Navigation</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    body { margin: 0; background: #000; overflow: hidden; font-family: 'Segoe UI', sans-serif; }
    canvas { display: block; }

    /* HUD */
    #hud {
      position: fixed;
      top: 20px;
      left: 20px;
      z-index: 100;
      pointer-events: none;
      text-shadow: 0 0 10px rgba(0, 150, 255, 0.8);
    }

    /* Joystick Containers */
    .joystick-container {
      position: fixed;
      bottom: 40px;
      width: 120px;
      height: 120px;
      background: rgba(255, 255, 255, 0.05);
      border: 2px solid rgba(255, 215, 0, 0.2);
      border-radius: 50%;
      touch-action: none;
      z-index: 1000;
    }
    #left-ctrl { left: 40px; }
    #right-ctrl { right: 40px; }

    .knob {
      position: absolute;
      width: 50px;
      height: 50px;
      background: radial-gradient(circle, #fff 0%, #ffcc00 100%);
      border-radius: 50%;
      top: 50%; left: 50%;
      transform: translate(-50%, -50%);
      box-shadow: 0 0 20px rgba(255, 215, 0, 0.5);
      pointer-events: none;
    }

    .label {
      position: absolute;
      width: 100%;
      text-align: center;
      bottom: -30px;
      color: #ffcc00;
      font-size: 10px;
      letter-spacing: 1px;
      text-transform: uppercase;
    }
  </style>
</head>
<body>

<div id="hud">
  <div class="text-2xl font-bold text-amber-400 tracking-tighter">STARFLY</div>
  <div id="pos-display" class="text-blue-300 font-mono text-xs mt-1">POS: 0, 0, 0</div>
</div>

<!-- Left Joystick: Up/Down/Left/Right -->
<div id="left-ctrl" class="joystick-container">
  <div id="left-knob" class="knob"></div>
  <div class="label">Move & Elevate</div>
</div>

<!-- Right Joystick: In/Out -->
<div id="right-ctrl" class="joystick-container">
  <div id="right-knob" class="knob"></div>
  <div class="label">Forward / Back</div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

<script>
'use strict';

/* ─── Scene Setup ───────────────────────────────────── */
const scene = new THREE.Scene();
scene.fog = new THREE.FogExp2(0x000000, 0.001);

const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 3000);
const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(window.devicePixelRatio);
document.body.appendChild(renderer.domElement);

/* ─── Background Starfield (Particle System) ───────── */
const starCount = 8000;
const starGeo = new THREE.BufferGeometry();
const starPos = new Float32Array(starCount * 3);
for (let i = 0; i < starCount * 3; i++) starPos[i] = (Math.random() - 0.5) * 2500;
starGeo.setAttribute('position', new THREE.BufferAttribute(starPos, 3));
const starMat = new THREE.PointsMaterial({ color: 0xffffff, size: 1.2, transparent: true, opacity: 0.8 });
const stars = new THREE.Points(starGeo, starMat);
scene.add(stars);

/* ─── Player Star (Golden-White) ────────────────────── */
const playerGroup = new THREE.Group();
scene.add(playerGroup);

const core = new THREE.Mesh(
    new THREE.SphereGeometry(0.6, 24, 24),
    new THREE.MeshBasicMaterial({ color: 0xffffff })
);
playerGroup.add(core);

const canvas = document.createElement('canvas');
canvas.width = 64; canvas.height = 64;
const ctx = canvas.getContext('2d');
const grad = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
grad.addColorStop(0, 'rgba(255, 255, 255, 1)');
grad.addColorStop(0.2, 'rgba(255, 215, 0, 0.8)');
grad.addColorStop(1, 'rgba(0, 0, 0, 0)');
ctx.fillStyle = grad; ctx.fillRect(0, 0, 64, 64);
const glowMap = new THREE.CanvasTexture(canvas);

const glow = new THREE.Sprite(new THREE.SpriteMaterial({ map: glowMap, blending: THREE.AdditiveBlending }));
glow.scale.set(8, 8, 1);
playerGroup.add(glow);

const pLight = new THREE.PointLight(0xffcc00, 2, 60);
playerGroup.add(pLight);

/* ─── Shooting Stars ────────────────────────────────── */
const shootingStars = [];
function createShootingStar() {
    const geo = new THREE.BufferGeometry();
    geo.setAttribute('position', new THREE.BufferAttribute(new Float32Array([0,0,0, 0,0,2]), 3));
    const mat = new THREE.LineBasicMaterial({ color: 0xffffff, transparent: true });
    const line = new THREE.Line(geo, mat);
    line.position.set((Math.random()-0.5)*1000, (Math.random()-0.5)*1000, (Math.random()-0.5)*1000);
    line.velocity = new THREE.Vector3((Math.random()-0.5)*50, (Math.random()-0.5)*50, (Math.random()-0.5)*50);
    scene.add(line);
    shootingStars.push(line);
}

/* ─── Input Logic ───────────────────────────────────── */
const keys = {};
window.addEventListener('keydown', e => keys[e.code] = true);
window.addEventListener('keyup', e => keys[e.code] = false);

const leftInput = new THREE.Vector2();  // x, y
const rightInput = new THREE.Vector2(); // y used for z-axis

function handleJoystick(id, knobId, inputVec) {
    const el = document.getElementById(id);
    const knob = document.getElementById(knobId);
    
    const handleMove = (e) => {
        const touch = e.touches ? e.touches[0] : e;
        const rect = el.getBoundingClientRect();
        const center = { x: rect.left + 60, y: rect.top + 60 };
        let dx = touch.clientX - center.x;
        let dy = touch.clientY - center.y;
        const dist = Math.min(50, Math.sqrt(dx*dx + dy*dy));
        const angle = Math.atan2(dy, dx);
        
        const moveX = Math.cos(angle) * dist;
        const moveY = Math.sin(angle) * dist;
        
        knob.style.transform = `translate(calc(-50% + ${moveX}px), calc(-50% + ${moveY}px))`;
        inputVec.set(moveX / 50, -moveY / 50); // Normalize to -1 to 1
    };

    const handleEnd = () => {
        knob.style.transform = `translate(-50%, -50%)`;
        inputVec.set(0, 0);
    };

    el.addEventListener('touchstart', e => { e.preventDefault(); handleMove(e); }, {passive: false});
    window.addEventListener('touchmove', e => { if(inputVec.lengthSq() > 0 || e.target === el) handleMove(e); }, {passive: false});
    window.addEventListener('touchend', handleEnd);
}

handleJoystick('left-ctrl', 'left-knob', leftInput);
handleJoystick('right-ctrl', 'right-knob', rightInput);

/* ─── Animation Loop ────────────────────────────────── */
const velocity = new THREE.Vector3();
const speed = 0.8;
const friction = 0.92;

function animate() {
    requestAnimationFrame(animate);

    // 1. Keyboard Inputs
    const move = new THREE.Vector3();
    if (keys['KeyW']) move.z -= 1;
    if (keys['KeyS']) move.z += 1;
    if (keys['KeyA']) move.x -= 1;
    if (keys['KeyD']) move.x += 1;
    if (keys['Space']) move.y += 1;
    if (keys['ShiftLeft']) move.y -= 1;

    // 2. Joystick Inputs (Override or Add)
    move.x += leftInput.x;
    move.y += leftInput.y;
    move.z -= rightInput.y; // Right stick Y controls Z axis

    if (move.length() > 0) move.normalize().multiplyScalar(speed);

    // 3. Physics
    velocity.add(move);
    velocity.multiplyScalar(friction);
    playerGroup.position.add(velocity);

    // 4. Camera Follow
    const camTarget = new THREE.Vector3(
        playerGroup.position.x,
        playerGroup.position.y + 4,
        playerGroup.position.z + 12
    );
    camera.position.lerp(camTarget, 0.1);
    camera.lookAt(playerGroup.position);

    // 5. Star Parallax (Infinite Feel)
    stars.position.copy(playerGroup.position).multiplyScalar(0.9);
    
    // 6. Shooting Stars
    if (Math.random() < 0.05) createShootingStar();
    shootingStars.forEach((s, i) => {
        s.position.add(s.velocity);
        s.material.opacity -= 0.01;
        if (s.material.opacity <= 0) {
            scene.remove(s);
            shootingStars.splice(i, 1);
        }
    });

    // 7. Update HUD
    const p = playerGroup.position;
    document.getElementById('pos-display').innerText = `POS: ${Math.round(p.x)}, ${Math.round(p.y)}, ${Math.round(p.z)}`;

    renderer.render(scene, camera);
}

window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
});

animate();
</script>

</body>
</html>
