<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>Starfly – 3D Star Map</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { background: #000; overflow: hidden; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
    canvas { display: block; }

    /* HUD overlay */
    #hud {
      position: fixed;
      top: 20px;
      left: 20px;
      color: rgba(180,220,255,0.9);
      font-size: 14px;
      pointer-events: none;
      text-shadow: 0 0 8px #4af;
      line-height: 1.6;
      letter-spacing: 1px;
    }

    /* Mobile virtual joystick */
    #joystick-zone {
      position: fixed;
      bottom: 40px;
      left: 40px;
      width: 120px;
      height: 120px;
      border-radius: 50%;
      background: rgba(100,180,255,0.1);
      border: 2px solid rgba(100,180,255,0.3);
      touch-action: none;
      display: none; 
    }
    #joystick-knob {
      position: absolute;
      width: 50px;
      height: 50px;
      border-radius: 50%;
      background: rgba(100,180,255,0.4);
      box-shadow: 0 0 15px rgba(100,180,255,0.5);
      top: 50%; left: 50%;
      transform: translate(-50%,-50%);
      pointer-events: none;
    }
  </style>
</head>
<body>

<div id="hud">
  <div style="font-weight: bold; font-size: 18px; margin-bottom: 4px;">STARFLY</div>
  <div id="pos-hud">Position: 0, 0, 0</div>
  <div style="margin-top:10px; font-size:11px; color:rgba(140,200,255,0.6);">
    WASD / Arrows – move <br>
    Space / Shift – up / down
  </div>
</div>

<div id="joystick-zone">
  <div id="joystick-knob"></div>
</div>

<!-- Three.js r158 via CDN -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/0.158.0/three.min.js"></script>

<script>
'use strict';

/* ─── Scene & Camera ───────────────────────────────── */
const scene = new THREE.Scene();
scene.fog = new THREE.FogExp2(0x000005, 0.0015);

const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 3000);
// Camera will be positioned dynamically in the loop

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setPixelRatio(window.devicePixelRatio);
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

/* ─── Lighting ─────────────────────────────────────── */
const ambient = new THREE.AmbientLight(0x4040ff, 0.5);
scene.add(ambient);

const playerLight = new THREE.PointLight(0xffdd66, 2, 50);
scene.add(playerLight);

/* ─── Background Star Field ────────────────────────── */
let starField;
function buildStarField() {
  const COUNT = 6000;
  const positions = new Float32Array(COUNT * 3);
  const colors = new Float32Array(COUNT * 3);
  
  for (let i = 0; i < COUNT; i++) {
    positions[i*3] = (Math.random() - 0.5) * 2000;
    positions[i*3+1] = (Math.random() - 0.5) * 2000;
    positions[i*3+2] = (Math.random() - 0.5) * 2000;
    
    const r = 0.8 + Math.random() * 0.2;
    const g = 0.8 + Math.random() * 0.2;
    const b = 1.0;
    colors[i*3] = r; colors[i*3+1] = g; colors[i*3+2] = b;
  }
  
  const geo = new THREE.BufferGeometry();
  geo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
  geo.setAttribute('color', new THREE.BufferAttribute(colors, 3));
  
  const mat = new THREE.PointsMaterial({ size: 1.5, vertexColors: true, transparent: true, opacity: 0.8 });
  starField = new THREE.Points(geo, mat);
  scene.add(starField);
}
buildStarField();

/* ─── Player Setup ─────────────────────────────────── */
const playerGroup = new THREE.Group();
scene.add(playerGroup);

const playerGeo = new THREE.SphereGeometry(0.5, 16, 16);
const playerMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
const playerMesh = new THREE.Mesh(playerGeo, playerMat);
playerGroup.add(playerMesh);

// Player Glow
const spriteMat = new THREE.SpriteMaterial({
  map: generateGlowTexture(),
  color: 0xffaa00,
  transparent: true,
  blending: THREE.AdditiveBlending
});
const sprite = new THREE.Sprite(spriteMat);
sprite.scale.set(5, 5, 1);
playerGroup.add(sprite);

function generateGlowTexture() {
  const canvas = document.createElement('canvas');
  canvas.width = 64; canvas.height = 64;
  const ctx = canvas.getContext('2d');
  const grad = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
  grad.addColorStop(0, 'rgba(255,255,255,1)');
  grad.addColorStop(0.2, 'rgba(255,255,255,0.8)');
  grad.addColorStop(0.5, 'rgba(255,200,0,0.2)');
  grad.addColorStop(1, 'rgba(0,0,0,0)');
  ctx.fillStyle = grad;
  ctx.fillRect(0, 0, 64, 64);
  return new THREE.CanvasTexture(canvas);
}

/* ─── Tail Trail ───────────────────────────────────── */
const MAX_TRAIL_POINTS = 30;
const trailPositions = new Float32Array(MAX_TRAIL_POINTS * 3);
const trailGeo = new THREE.BufferGeometry();
trailGeo.setAttribute('position', new THREE.BufferAttribute(trailPositions, 3));
const trailMat = new THREE.LineBasicMaterial({ color: 0xffcc00, transparent: true, opacity: 0.5 });
const trailLine = new THREE.Line(trailGeo, trailMat);
scene.add(trailLine);

const trailHistory = [];

/* ─── Controls ─────────────────────────────────────── */
const keys = {};
window.addEventListener('keydown', e => keys[e.code] = true);
window.addEventListener('keyup', e => keys[e.code] = false);

let mouseX = 0, mouseY = 0;
window.addEventListener('mousemove', e => {
  mouseX = (e.clientX / window.innerWidth) - 0.5;
  mouseY = (e.clientY / window.innerHeight) - 0.5;
});

// Joystick Logic
const joystickZone = document.getElementById('joystick-zone');
const joystickKnob = document.getElementById('joystick-knob');
let joystickActive = false;
let joystickVector = new THREE.Vector2(0, 0);

if ('ontouchstart' in window) {
  joystickZone.style.display = 'block';
}

joystickZone.addEventListener('touchstart', e => {
  joystickActive = true;
}, {passive: false});

window.addEventListener('touchmove', e => {
  if (!joystickActive) return;
  const touch = e.touches[0];
  const rect = joystickZone.getBoundingClientRect();
  const centerX = rect.left + rect.width / 2;
  const centerY = rect.top + rect.height / 2;
  
  let dx = touch.clientX - centerX;
  let dy = touch.clientY - centerY;
  const dist = Math.min(60, Math.sqrt(dx*dx + dy*dy));
  const angle = Math.atan2(dy, dx);
  
  const moveX = Math.cos(angle) * dist;
  const moveY = Math.sin(angle) * dist;
  
  joystickKnob.style.transform = `translate(calc(-50% + ${moveX}px), calc(-50% + ${moveY}px))`;
  joystickVector.set(moveX / 60, moveY / 60);
}, {passive: false});

window.addEventListener('touchend', () => {
  joystickActive = false;
  joystickVector.set(0, 0);
  joystickKnob.style.transform = `translate(-50%, -50%)`;
});

/* ─── Main Loop ────────────────────────────────────── */
const velocity = new THREE.Vector3();
const speed = 0.6;
const friction = 0.95;
const clock = new THREE.Clock();

function animate() {
  requestAnimationFrame(animate);
  const dt = clock.getDelta();

  // 1. Movement Input
  const input = new THREE.Vector3();
  if (keys['KeyW'] || keys['ArrowUp']) input.z -= 1;
  if (keys['KeyS'] || keys['ArrowDown']) input.z += 1;
  if (keys['KeyA'] || keys['ArrowLeft']) input.x -= 1;
  if (keys['KeyD'] || keys['ArrowRight']) input.x += 1;
  if (keys['Space']) input.y += 1;
  if (keys['ShiftLeft']) input.y -= 1;

  // Add joystick to input
  input.x += joystickVector.x;
  input.z += joystickVector.y;

  if (input.length() > 0) input.normalize().multiplyScalar(speed);

  // 2. Apply Velocity
  velocity.add(input);
  velocity.multiplyScalar(friction);
  playerGroup.position.add(velocity);
  playerLight.position.copy(playerGroup.position);

  // 3. Update Trail
  trailHistory.push(playerGroup.position.clone());
  if (trailHistory.length > MAX_TRAIL_POINTS) trailHistory.shift();

  const posAttr = trailGeo.attributes.position;
  for (let i = 0; i < MAX_TRAIL_POINTS; i++) {
    const point = trailHistory[i] || playerGroup.position;
    posAttr.setXYZ(i, point.x, point.y, point.z);
  }
  posAttr.needsUpdate = true;

  // 4. Camera Logic
  // Camera follows behind player with a slight lag (lerp)
  const idealOffset = new THREE.Vector3(mouseX * 10, 5 + (-mouseY * 10), 15);
  const targetCamPos = playerGroup.position.clone().add(idealOffset);
  camera.position.lerp(targetCamPos, 0.1);
  camera.lookAt(playerGroup.position);

  // 5. Background Follow (Infinite effect)
  starField.position.copy(playerGroup.position).multiplyScalar(0.9); // Parallax
  starField.rotation.y += 0.0005;

  // 6. HUD update
  const p = playerGroup.position;
  document.getElementById('pos-hud').innerText = `Position: ${Math.floor(p.x)}, ${Math.floor(p.y)}, ${Math.floor(p.z)}`;

  renderer.render(scene, camera);
}

// Handle Resize
window.addEventListener('resize', () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});

animate();
</script>
</body>
</html>