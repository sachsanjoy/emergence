<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>Starfly – Crystal Collector</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    body { margin: 0; background: #000; overflow: hidden; font-family: 'Inter', sans-serif; }
    canvas { display: block; }

    /* HUD */
    #hud {
      position: fixed;
      top: 25px;
      left: 25px;
      z-index: 100;
      pointer-events: none;
    }
    #score-hud {
      font-size: 24px;
      color: #00d2ff;
      text-shadow: 0 0 15px rgba(0, 210, 255, 0.7);
      font-weight: 800;
      margin-top: 5px;
    }

    /* Left Joystick: Steering */
    #joy-container {
      position: fixed;
      bottom: 50px;
      left: 50px;
      width: 130px;
      height: 130px;
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid rgba(255, 215, 0, 0.2);
      border-radius: 50%;
      touch-action: none;
      z-index: 1000;
    }
    #joy-knob {
      position: absolute;
      width: 50px;
      height: 50px;
      background: radial-gradient(circle, #fff, #ffcc00);
      border-radius: 50%;
      top: 50%; left: 50%;
      transform: translate(-50%, -50%);
      box-shadow: 0 0 20px rgba(255, 215, 0, 0.4);
      pointer-events: none;
    }

    /* Right Button: Thrust */
    #thrust-btn {
      position: fixed;
      bottom: 60px;
      right: 60px;
      width: 110px;
      height: 110px;
      background: rgba(255, 215, 0, 0.1);
      border: 3px solid #ffcc00;
      border-radius: 50%;
      color: #ffcc00;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: 900;
      text-transform: uppercase;
      letter-spacing: 2px;
      user-select: none;
      z-index: 1000;
      box-shadow: 0 0 20px rgba(255, 215, 0, 0.2);
    }
    #thrust-btn:active {
      background: rgba(255, 215, 0, 0.4);
      transform: scale(0.92);
    }
  </style>
</head>
<body>

<div id="hud">
  <div class="text-xl font-black text-amber-400 italic tracking-tighter">STARFLY</div>
  <div id="score-hud">CRYSTALS: 0</div>
  <div id="pos-display" class="text-white font-mono text-[10px] opacity-40 mt-1">X: 0 Y: 0 Z: 0</div>
</div>

<div id="joy-container">
  <div id="joy-knob"></div>
</div>

<div id="thrust-btn">THRUST</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

<script>
'use strict';

/* ─── Scene & Camera ───────────────────────────────── */
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 5000);
const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
document.body.appendChild(renderer.domElement);

/* ─── Background Star Field ────────────────────────── */
const starCount = 8000;
const starGeo = new THREE.BufferGeometry();
const starPos = new Float32Array(starCount * 3);
for (let i = 0; i < starCount * 3; i++) starPos[i] = (Math.random() - 0.5) * 3500;
starGeo.setAttribute('position', new THREE.BufferAttribute(starPos, 3));
const stars = new THREE.Points(starGeo, new THREE.PointsMaterial({ color: 0xffffff, size: 1.2, transparent: true, opacity: 0.6 }));
scene.add(stars);

/* ─── Player (Golden-White Star) ───────────────────── */
const playerGroup = new THREE.Group();
scene.add(playerGroup);

const playerCore = new THREE.Mesh(
    new THREE.SphereGeometry(0.6, 32, 32),
    new THREE.MeshBasicMaterial({ color: 0xffffff })
);
playerGroup.add(playerCore);

// Glow Sprite
const canvas = document.createElement('canvas');
canvas.width = 64; canvas.height = 64;
const ctx = canvas.getContext('2d');
const grad = ctx.createRadialGradient(32,32,0, 32,32,32);
grad.addColorStop(0,'white'); grad.addColorStop(0.3,'#ffcc00'); grad.addColorStop(1,'transparent');
ctx.fillStyle = grad; ctx.fillRect(0,0,64,64);
const glowSprite = new THREE.Sprite(new THREE.SpriteMaterial({ map: new THREE.CanvasTexture(canvas), blending: THREE.AdditiveBlending }));
glowSprite.scale.set(8, 8, 1);
playerGroup.add(glowSprite);

const pLight = new THREE.PointLight(0xffcc00, 2, 60);
playerGroup.add(pLight);

/* ─── Blue Crystal System ──────────────────────────── */
const crystals = [];
const MAX_CRYSTALS = 5;
let score = 0;
const SPAWN_DISTANCE = 45; // Approx distance for 3s travel at max speed

function spawnCrystal() {
    const geo = new THREE.OctahedronGeometry(0.5, 0);
    const mat = new THREE.MeshBasicMaterial({ color: 0x00d2ff, wireframe: false });
    const crystal = new THREE.Mesh(geo, mat);
    
    // Random spherical position around player
    const phi = Math.random() * Math.PI * 2;
    const theta = Math.random() * Math.PI;
    const r = SPAWN_DISTANCE + (Math.random() * 10);
    
    crystal.position.set(
        playerGroup.position.x + r * Math.sin(theta) * Math.cos(phi),
        playerGroup.position.y + r * Math.sin(theta) * Math.sin(phi),
        playerGroup.position.z + r * Math.cos(theta)
    );
    
    // Tiny blue glow
    const cLight = new THREE.PointLight(0x00d2ff, 1, 10);
    crystal.add(cLight);
    
    scene.add(crystal);
    crystals.push(crystal);
}

/* ─── Movement Logic ───────────────────────────────── */
let thrustActive = false;
let rotationInput = new THREE.Vector2(0, 0);
const velocity = new THREE.Vector3();
const rotationEuler = new THREE.Euler(0, 0, 0, 'YXZ');
const moveSpeed = 0.55;
const rotateSpeed = 0.045;
const damping = 0.96;

// Controls
const joyContainer = document.getElementById('joy-container');
const joyKnob = document.getElementById('joy-knob');
const thrustBtn = document.getElementById('thrust-btn');

function handleJoystick(e) {
    e.preventDefault();
    const touch = e.touches ? e.touches[0] : e;
    const rect = joyContainer.getBoundingClientRect();
    const dx = touch.clientX - (rect.left + 65);
    const dy = touch.clientY - (rect.top + 65);
    const dist = Math.min(50, Math.sqrt(dx*dx + dy*dy));
    const angle = Math.atan2(dy, dx);
    joyKnob.style.transform = `translate(calc(-50% + ${Math.cos(angle)*dist}px), calc(-50% + ${Math.sin(angle)*dist}px))`;
    rotationInput.set(-dy/50, -dx/50);
}

joyContainer.addEventListener('touchstart', handleJoystick);
window.addEventListener('touchmove', (e) => { if(e.touches[0].target === joyContainer || e.touches.length > 0) handleJoystick(e); });
window.addEventListener('touchend', () => { joyKnob.style.transform = `translate(-50%,-50%)`; rotationInput.set(0,0); });

thrustBtn.addEventListener('touchstart', (e) => { e.preventDefault(); thrustActive = true; });
window.addEventListener('touchend', () => thrustActive = false);

/* ─── Animation Loop ────────────────────────────────── */
function animate() {
    requestAnimationFrame(animate);

    // 1. Manage Crystal Spawning
    while (crystals.length < MAX_CRYSTALS) {
        spawnCrystal();
    }

    // 2. Rotation & Steering
    rotationEuler.x += rotationInput.x * rotateSpeed;
    rotationEuler.y += rotationInput.y * rotateSpeed;
    playerGroup.setRotationFromEuler(rotationEuler);

    // 3. Thrust & Velocity
    if (thrustActive) {
        const dir = new THREE.Vector3(0, 0, -1).applyQuaternion(playerGroup.quaternion);
        velocity.add(dir.multiplyScalar(moveSpeed));
    }
    playerGroup.position.add(velocity);
    velocity.multiplyScalar(damping);

    // 4. Collection Detection
    for (let i = crystals.length - 1; i >= 0; i--) {
        const crystal = crystals[i];
        crystal.rotation.y += 0.05; // Spin crystal
        
        const dist = playerGroup.position.distanceTo(crystal.position);
        if (dist < 2.2) { // Collection radius
            scene.remove(crystal);
            crystals.splice(i, 1);
            score++;
            document.getElementById('score-hud').innerText = `CRYSTALS: ${score}`;
        }
    }

    // 5. Camera & Parallax
    const camOffset = new THREE.Vector3(0, 3, 14).applyQuaternion(playerGroup.quaternion);
    camera.position.lerp(playerGroup.position.clone().add(camOffset), 0.1);
    camera.lookAt(playerGroup.position);
    stars.position.copy(playerGroup.position).multiplyScalar(0.9);

    // 6. HUD
    const p = playerGroup.position;
    document.getElementById('pos-display').innerText = `X:${Math.round(p.x)} Y:${Math.round(p.y)} Z:${Math.round(p.z)}`;

    renderer.render(scene, camera);
}

window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
});

animate();
</script>
</body>
</html>